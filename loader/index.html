<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beads â€“ Universal Quality</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background: #F8F3EA; }
    canvas { display: block; }
  </style>
</head>
<body>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import * as CANNON from 'https://cdn.skypack.dev/cannon-es';

// Detect iPhone/Safari
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

let scene, camera, renderer;
const beads = [], bodies = [], spinAxes = [];

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color('#F8F3EA');

  camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 100);
  camera.position.z = 18;

  renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: 'high-performance' });
  renderer.setPixelRatio(isIOS ? 1.2 : window.devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const light1 = new THREE.DirectionalLight(0xffffff, 2);
  light1.position.set(5, 10, 7);
  scene.add(light1);
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));

  const envMap = new THREE.CubeTextureLoader()
    .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
    .load(['posx.jpg','negx.jpg','posy.jpg','negy.jpg','posz.jpg','negz.jpg']);
  scene.environment = envMap;

  const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -0.35, 0) });

  const colors = [
    '#fef3f7', '#fdb3c8', '#ffe0b2', '#ffe57f', '#c8e6c9',
    '#80deea', '#b39ddb', '#90caf9', '#ffab91', '#aed581',
    '#f06292', '#ce93d8', '#4dd0e1', '#ff7043', '#a5d6a7', '#ba68c8'
  ];

  const shapes = [
    { outer: 0.30, tube: 0.11 },
    { outer: 0.35, tube: 0.14 },
    { outer: 0.40, tube: 0.16 },
    { outer: 0.45, tube: 0.18 }
  ];

  for (let i = 0; i < 200; i++) {
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
    const geometry = new THREE.TorusGeometry(shape.outer, shape.tube, 32, 64);

    // iOS-safe material
    const material = isIOS
      ? new THREE.MeshStandardMaterial({
          color,
          metalness: 0.1,
          roughness: 0.2,
          opacity: 0.85,
          transparent: true,
          envMap,
          envMapIntensity: 0.4
        })
      : new THREE.MeshPhysicalMaterial({
          color,
          transmission: 0.94,
          thickness: 1.2,
          roughness: 0,
          clearcoat: 1,
          clearcoatRoughness: 0,
          reflectivity: 1,
          envMap,
          envMapIntensity: 1.4,
          metalness: 0.1,
          sheen: 1,
          sheenColor: color,
          sheenRoughness: 0.2,
          iridescence: 0.2,
          iridescenceIOR: 1.3,
          transparent: true,
          opacity: 0.94
        });

    const mesh = new THREE.Mesh(geometry, material);
    const zScale = THREE.MathUtils.lerp(1.4, 1.9, Math.random());
    mesh.scale.set(1, 1, zScale);
    scene.add(mesh);

    const body = new CANNON.Body({ mass: 0.35 + Math.random() * 0.15 });
    body.addShape(new CANNON.Sphere(shape.outer));
    body.position.set((Math.random() - 0.5) * 20, Math.random() * 20 + 10, (Math.random() - 0.5) * 10);
    body.linearDamping = 0.18 + Math.random() * 0.1;
    body.angularDamping = 0.25;
    world.addBody(body);

    spinAxes.push(new THREE.Vector3(
      Math.random() * 0.01,
      Math.random() * 0.01,
      Math.random() * 0.01
    ));

    beads.push(mesh);
    bodies.push(body);
  }

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  function animate() {
    world.step(1 / 60);

    beads.forEach((mesh, i) => {
      const body = bodies[i];
      mesh.position.copy(body.position);
      mesh.rotation.x += spinAxes[i].x;
      mesh.rotation.y += spinAxes[i].y;
      mesh.rotation.z += spinAxes[i].z;

      if (body.position.y < -20) {
        body.position.set((Math.random() - 0.5) * 20, 20 + Math.random() * 5, (Math.random() - 0.5) * 10);
        body.velocity.set(0, 0, 0);
        body.angularVelocity.set(0, 0, 0);
      }
    });

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();
}

init();
</script>

</body>
</html>
